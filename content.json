{"meta":{"title":"Yc's notes","subtitle":null,"description":null,"author":"Yc","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"mysql忘记root密码","slug":"mysql忘记root密码","date":"2018-04-04T08:08:28.000Z","updated":"2018-04-04T08:12:37.542Z","comments":true,"path":"2018/04/04/mysql忘记root密码/","link":"","permalink":"http://yoursite.com/2018/04/04/mysql忘记root密码/","excerpt":"","text":"今天意外的发现很久没有使用的mysql数据库密码忘记了..于是就秀一波操作吧.. 12345678sudo vim /etc/mysql/my.cnfskip-grant-tables //添加这句话，见名知意，绕过授权sudo service mysql restartsudo mysql -u rootuse mysql;update user set password=password(&apos;root&apos;) where user=&apos;root&apos;; flush privileges;quit 最后记得把skip-grant-tables 干掉..","categories":[],"tags":[]},{"title":"mysqlConnectiotException","slug":"mysqlConnectiotException","date":"2016-03-04T08:08:28.000Z","updated":"2018-04-04T10:58:14.179Z","comments":true,"path":"2016/03/04/mysqlConnectiotException/","link":"","permalink":"http://yoursite.com/2016/03/04/mysqlConnectiotException/","excerpt":"","text":"改表法。可能是你的帐号不允许从远程登陆，只能在localhost。这个时候只要在localhost的那台电脑，登入mysql后，更改 “mysql” 数据库里的 “user” 表里的 “host” 项，从”localhost”改称”%” mysql -u root -pvmwaremysql&gt;use mysql; mysql&gt;update user set host = ‘%’ where user = ‘root’; mysql&gt;select host, user from user; 授权法。 GRANT ALL PRIVILEGES ON . TO ‘myuser’@’%’IDENTIFIED BY ‘mypassword’ WI TH GRANT OPTION; 如果你想允许用户myuser从ip为192.168.1.6的主机连接到mysql服务器，并使用mypassword作为密码 GRANT ALL PRIVILEGES ON . TO ‘myuser’@’192.168.1.3’IDENTIFIED BY ‘mypassword’ WITH GRANT OPTION; 我用的第一个方法,刚开始发现不行,在网上查了一下,少执行一个语句 mysql&gt;FLUSH RIVILEGES 使修改生效，就可以了 另外一种方法： 在安装mysql的机器上运行： 1.d:\\mysql\\bin&gt;mysql -h localhost -u root //这样应该可以进入MySQL服务器2.mysql&gt;GRANT ALL PRIVILEGES ON . TO ‘root’@’%’WITH GRANT OPTION //赋予任何主机访问数据的权限 3. mysql&gt;FLUSH PRIVILEGES //修改生效4.mysql&gt;EXIT //退出MySQL服务器 这样就可以在其它任何的主机上以root身份登录啦 授权语句:123 grant all privileges on *.* to &apos;root&apos;@&apos;%&apos; identified by &apos;root&apos; with grant option;//授权后刷新权限flush privileges 注: 将root 改为你的mysql用户修改数据库中的root密码，登陆后在mysql终端输入：1update mysql.user set password=PASSWORD(&apos;111111&apos;) where user=&apos;root&apos;; 转载自： http://blog.csdn.net/xinshou_jiaoming/article/details/8585562 参考连接：http://www.2cto.com/database/201412/364316.html","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}]},{"title":"设计模式总结","slug":"设计模式总结","date":"2016-02-05T08:08:28.000Z","updated":"2018-04-04T10:51:44.039Z","comments":true,"path":"2016/02/05/设计模式总结/","link":"","permalink":"http://yoursite.com/2016/02/05/设计模式总结/","excerpt":"","text":"#设计模式总结 ##创建型模式 ###1. 抽象工厂模式名称：抽象工厂意图：提供一个创建一系列相关或相互依赖对象的接口，而无需制定他们具体的类。应用场景：（1）系统独立于它的创建、组合和表示。（2）一个系统要由多个产品系列中的一个来配置的。（3）当强调一系列相关的产品对象的设计以便联合使用。（4）若提供类库，只想提供接口，而不是实现。java例子：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// 抽象工厂接口：public interface AbstractFactory &#123; public Shoes GreateShoes(); // 生产鞋子 public Hat GreateHat(); // 生产帽子&#125;//实例工厂1：public class Factory1 implements AbstractFactory &#123; @Override public Shoes GreateShoes() &#123; //工厂1创建运动鞋 System.out.print(\"工厂1\"); return new SportShoes(); &#125; @Override public Hat GreateHat() &#123; //工厂1创建红帽子 System.out.print(\"工厂1\"); return new RedHat(); &#125;&#125;//实例工厂2：public class Factory2 implements AbstractFactory &#123; @Override public Shoes GreateShoes() &#123; System.out.print(\"工厂2\"); return new CasualShoes(); //工厂2创建休闲鞋 &#125; @Override public Hat GreateHat() &#123; System.out.print(\"工厂2\"); return new WhiteHat(); //工厂2创建白帽子 &#125;&#125;//帽子类型接口：public interface Hat &#123; &#125;//帽子的实现类红帽子：public class RedHat implements Hat &#123; RedHat()&#123; System.out.println(\"创建红帽子\"); &#125;&#125;//帽子的实现类白帽子：public class WhiteHat implements Hat &#123; WhiteHat()&#123; System.out.println(\"创建白帽子\"); &#125;&#125;//鞋子类型接口public interface Shoes &#123; &#125;//鞋子的实现类运动鞋public class SportShoes implements Shoes &#123; SportShoes()&#123; System.out.println(\"创建运动鞋\"); &#125;&#125;//鞋子的实现类休闲鞋public class CasualShoes implements Shoes &#123; CasualShoes()&#123; System.out.println(\"创建休闲鞋\"); &#125;&#125;//客户端public class Client &#123; public static void main(String[] args) &#123; Shoes shoes = new Factory1().GreateShoes(); Shoes shoes1 = new Factory2().GreateShoes(); Hat hat1 = new Factory1().GreateHat(); Hat hat2 = new Factory2().GreateHat(); &#125;&#125; ###2. 生成器模式名称：生成器模式 &nbsp;&nbsp; 别名：建造模式模式意图：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。应用场景：（1）当创建复杂对象的算法应该独立于与该对象的组成部分以及他们的装配方式时。（2）当构造过程必须被构造的对象有不同的表示时。java例子:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//基类:class Computer &#123; private String Screen; //显示屏幕 private String Mouse; //鼠标 private String KeyBoard; //键盘 public void setScreen(String screen) &#123; Screen = screen; &#125; public void setMouse(String mouse) &#123; Mouse = mouse; &#125; public void setKeyBoard(String keyBoard) &#123; KeyBoard = keyBoard; &#125; public String toString() &#123; return \"Computer [Screen=\" + Screen + \", Mouse=\" + Mouse+ \", KeyBoard=\" + KeyBoard + \"]\"; &#125;&#125;//创建电脑的类public abstract class ComputerBuilder &#123; protected Computer computer; public Computer getComputer()&#123; return computer; &#125; public void createNewComputer()&#123; computer = new Computer();&#125; public abstract void buildScreen(); public abstract void buildMouse(); public abstract void buildKeyBoard();&#125;//实现类 联想电脑class LenovoComputer extends ComputerBuilder &#123; public void buildScreen() &#123;computer.setScreen(\"lenovo screen\");&#125; public void buildMouse() &#123;computer.setMouse(\"lenovo mouse\");&#125; public void buildKeyBoard() &#123;computer.setKeyBoard(\"lenovo keyBoard\");&#125;&#125;//实现类 戴尔电脑class DellComputer extends ComputerBuilder&#123; public void buildScreen() &#123;computer.setScreen(\"dell screen\");&#125; public void buildMouse() &#123;computer.setMouse(\"dell mouse\");&#125; public void buildKeyBoard() &#123;computer.setKeyBoard(\"dell keyBoard\");&#125;&#125;//售货员类public class Assisstant &#123; private ComputerBuilder cb; //传入一个电脑的厂家 public Computer getComputer()&#123;return cb.getComputer();&#125; public void setComputerBuilder(ComputerBuilder cb)&#123;this.cb = cb;&#125; public void createNewComputer()&#123; cb.createNewComputer(); //创建新的电脑 cb.buildKeyBoard(); //创建键盘 cb.buildMouse(); //创建鼠标 cb.buildScreen(); //创建显示器 &#125;&#125;//客户端public class Client &#123; public static void main(String[] args) &#123; Assisstant as = new Assisstant(); ComputerBuilder lenovo = new LenovoComputer(); ComputerBuilder deel = new DellComputer(); as.setComputerBuilder(lenovo); as.createNewComputer(); Computer computer = as.getComputer(); System.out.println(computer); as.setComputerBuilder(deel); as.createNewComputer(); Computer computer1 = as.getComputer(); System.out.println(computer1); &#125;&#125; ###3. 原型模式名称 ： 原型模式意图：用原型实例制定创建对象的种类，并且通过拷贝这些原型创建新的对象。应用场景：（1）当要实例化的类是在运行时刻制定时，例如，通过动态装载。（2）为了避免创建一个与产品层次平行的工厂类层次时。（3）当一个类的实例只能有几个不同状态组合中的一种时。java例子:1234567891011121314151617181920212223242526272829303132333435363738//原型接口public interface Prototype &#123; public Object cloneMe() throws CloneNotSupportedException;&#125;//通过克隆得到对象public class Cublic implements Prototype, Cloneable &#123; public Object cloneMe() throws CloneNotSupportedException &#123; return (Cublic)clone(); &#125; public String toString() &#123;return \"Cublic []\";&#125;&#125;//通过序列化得到对象public class Goat implements Prototype, Serializable &#123; public String toString() &#123;return \"Goat []\";&#125; public Object cloneMe() throws CloneNotSupportedException &#123; Object obj = null; try &#123; ByteArrayOutputStream outOne = new ByteArrayOutputStream(); ObjectOutputStream outTwo = new ObjectOutputStream(outOne); outTwo.writeObject(this); ByteArrayInputStream inOne = new ByteArrayInputStream(outOne.toByteArray()); ObjectInputStream inTwo = new ObjectInputStream(inOne); obj = inTwo.readObject(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return obj; &#125;&#125;//客户端public class Client &#123; public static void main(String[] args) throws CloneNotSupportedException &#123; Goat goat = new Goat(); System.out.println(\"通过对象流得到：\"+goat.cloneMe()); Cublic cb = new Cublic(); System.out.println(\"通过拷贝得到：\"+cb.cloneMe()); &#125;&#125; ##结构型模式 ###1. 适配器模式模式名称：适配器模式 &nbsp;&nbsp;别名：包装器 意图：将一个类的接口转换成客户希望的另一个接口。应用场景：（1）想要使用某个已经存在的类，而它的接口不符合需求。（2）想要创建一个可复用的类，该类可以和其他部相关的类或不可预见的类协同工作。（3）想要使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配他们的接口。对象的适配器可以适配它父类的接口。java例子:12345678910111213141516171819202122232425262728293031323334353637383940//三孔插座接口public interface ThreeSocketInf &#123; public void powerWithThreeSocket();&#125;//三孔插座实现public class ThreeSocket implements ThreeSocketInf &#123; public void powerWithThreeSocket() &#123; System.out.print(\"使用三孔插座充电\"); &#125;&#125;//两孔插座接口public interface TwoSocketInf &#123; public void powerWithTwoSocket();&#125;//两孔插座实现public class TwoSocket implements TwoSocketInf &#123; public void powerWithTwoSocket() &#123; System.out.println(\"使用两孔插座充电\"); &#125;&#125;//适配器public class SocketAdapter implements TwoSocketInf &#123; private ThreeSocketInf ts; public SocketAdapter(ThreeSocketInf ts) &#123; this.ts = ts; &#125; @Override public void powerWithTwoSocket() &#123; ts.powerWithThreeSocket(); System.out.print(\"---&gt; 适配为两口\"); &#125;&#125;//客户端public class Client &#123; public static void main(String[] args) &#123; ThreeSocketInf three = new ThreeSocket(); SocketAdapter sa = new SocketAdapter(three); sa.powerWithTwoSocket(); &#125;&#125; ###2. 适配器模式模式名称：桥接模式意图：将抽象部分与实现部分分离，使它们都可以独立的变化。应用场景：（1）如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的联系。（2）设计要求实现化角色的任何改变不应当影响客户端，或者说实现化角色的改变对客户端是完全透明的。（3）一个构件有多于一个的抽象化角色和实现化角色，系统需要它们之间进行动态耦合。（4）．虽然在系统中使用继承是没有问题的，但是由于抽象化角色和具体化角色需要独立变化，设计要求需要独立管理这两者。java例子：12345678910111213141516171819202122232425262728293031323334353637383940414243//抽象车public class AbstractCar &#123; void run()&#123; System.out.println(\"车\");&#125;&#125;//实例公交车public class Bus extends AbstractCar &#123; void run()&#123; System.out.print(\"公交车\");&#125;&#125;//实例小轿车public class Car extends AbstractCar &#123; void run()&#123; System.out.print(\"小轿车\");&#125;&#125;//抽象路public class Road &#123; AbstractCar car; public void run()&#123; System.out.println(\"道路\"); &#125;&#125;//实例街道路public class StreetRode extends Road &#123; public void run()&#123; car.run(); System.out.println(\"在街区路行驶\"); &#125;&#125;//实例高速路public class SpeedWay extends Road &#123; public void run()&#123; car.run(); System.out.print(\"在高速路行驶\"); &#125;&#125;//客户端public class Client &#123; public static void main(String[] args) &#123; Road road =new SpeedWay(); road.car = new Car(); road.run(); System.out.println(); Road road1 =new StreetRode(); road1.car = new Bus(); road1.run(); &#125;&#125; ###3.代理模式模式名称：代理模式意图：为其他对象提供一种代理以控制对这个对象的访问。应用场景：(1)远程代理(Remote Proxy) -可以隐藏一个对象存在于不同地址空间的事实。也使得客户端可以访问在远程机器上的对象，远程机器可能具有更好的计算性能与处理速度，可以快速响应并处理客户端请求。(2)虚拟代理(Virtual Proxy) – 允许内存开销较大的对象在需要的时候创建。只有我们真正需要这个对象的时候才创建。(3)写入时复制代理(Copy-On-Write Proxy) – 用来控制对象的复制，方法是延迟对象的复制，直到客户真的需要为止。是虚拟代理的一个变体。(4)保护代理(Protection (Access)Proxy) – 为不同的客户提供不同级别的目标对象访问权限。java例子：12345678910111213141516171819202122232425//抽象对象public abstract class Subject &#123; abstract public void request(); &#125;//真实对象public class RealSubject extends Subject &#123; public void request() &#123;System.out.println(\"真实对象处理请求\");&#125;&#125;//代理与相同对象继承相同的类public class ProxySubject extends Subject &#123; private RealSubject rs; //持有真实对象的引用 @Override public void request() &#123; if(rs == null ) rs = new RealSubject(); System.out.print(\"通过代理 \"); rs.request(); &#125;&#125;//客户端通过代理来调用真实对象public class Client &#123; public static void main(String[] args) &#123; ProxySubject ps = new ProxySubject(); ps.request(); &#125;&#125; ##行为型模式 ###1.命令模式模式名称：命令模式 &nbsp;&nbsp;别名：动作、事务模式意图：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤消的操作。应用场景:（1）整个调用过程比较繁杂，或者存在多处这种调用。这时，使用Command类对该调用加以封装，便于功能的再利用。（2）调用前后需要对调用参数进行某些处理。（3）调用前后需要进行某些额外处理，比如日志，缓存，记录历史操作等。java例子:1234567891011121314151617181920212223242526272829303132//命令接口public interface Command &#123; public abstract void execute();&#125;//生成命令的实现类public class ConcerteCommand implements Command &#123; CompanyArmy ca; ConcerteCommand(CompanyArmy ca)&#123; this.ca = ca; &#125; public void execute() &#123;ca.sneakAttack();&#125;&#125;//指挥者public class ArySuperior &#123; Command command; public void setCommand(Command command) &#123;this.command = command;&#125; public void startExecuteCommand()&#123;command.execute();&#125;&#125;//命令执行者public class CompanyArmy &#123; public void sneakAttack()&#123; System.out.println(\"三连收到袭击敌人的任务，保证完成任务\"); &#125;&#125;//客户端public class Client &#123; public static void main(String[] args) &#123; CompanyArmy 三连 = new CompanyArmy(); Command command = new ConcerteCommand(三连); ArySuperior 指挥官 = new ArySuperior(); 指挥官.setCommand(command); 指挥官.startExecuteCommand(); &#125;&#125; ###2.观察者模式模式名称：观察者模式 &nbsp;&nbsp;别名：依赖、发布、订阅模式意图：定义对象间的一种一对多的依赖关系，当一个对象的状态发生变化时，所有依赖它的对象得到通知并被自动更新。应用场景:（1）当一个抽象模型有两个方面,其中一个方面依赖于另一方面。（2）当对一个对象的改变需要同时改变其它对象,而不知道具体有多少对象有待改变。（3）当一个对象必须通知其它对象，而它又不能假定其它对象是谁。java例子:1234567891011121314151617181920212223242526272829303132333435363738//抽象观察者public interface Watcher &#123; public void update(String str);&#125;//生成具体观察者public class ConcreteWatcher implements Watcher &#123; public void update(String str) &#123; System.out.println(str); &#125;&#125;//管理观察者的接口public interface Watched &#123; public void addWatcher(Watcher watcher); public void removeWatcher(Watcher watcher); public void notifyWatchers(String str);&#125;//实现管理观察者public class ConcreteWatched implements Watched &#123; private List&lt;Watcher&gt; list = new ArrayList&lt;Watcher&gt;(); public void addWatcher(Watcher watcher) &#123;list.add(watcher);&#125; public void removeWatcher(Watcher watcher) &#123;list.remove(watcher);&#125; public void notifyWatchers(String str) &#123; for(Watcher l : list) l.update(str); &#125;&#125;//客户端public class Client &#123; public static void main(String[] args) &#123; Watched watched = new ConcreteWatched(); Watcher watcher1 = new ConcreteWatcher(); Watcher watcher2 = new ConcreteWatcher(); Watcher watcher3 = new ConcreteWatcher(); watched.addWatcher(watcher1); watched.addWatcher(watcher2); watched.addWatcher(watcher3); watched.notifyWatchers(\"哈哈\"); &#125;&#125; ###3.迭代器模式模式名称：迭代器模式 &nbsp;&nbsp;别名：游标模式意图：提供一种方法顺序访问一个聚合对象中的各个元素，而不需要暴露改对象内部表示。应用场景:（1）访问一个聚合对象的内容而无需暴露它的内部表示。（2）支持对聚合对象的多种遍历。（3）为遍历不同的聚合结构提供统一的接口。 java 例子：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//迭代器接口public interface Iterator &#123; public Object first(); public Object next(); public Object currentItem(); public boolean isDone();&#125;//迭代器实现类public class ConcreteIterator implements Iterator &#123; private int currentIndex = 0; private Vector vector = null; public ConcreteIterator(final Vector vector)&#123; this.vector = vector; &#125; public long applyAsLong(int value) &#123; return 0; &#125; public Object first() &#123; currentIndex = 0; return vector.get(currentIndex); &#125; public Object next() &#123; currentIndex++; return vector.get(currentIndex); &#125; public Object currentItem() &#123; return vector.get(currentIndex); &#125; public boolean isDone() &#123; if (currentIndex &gt;= this.vector.size() - 1) return true; else return false; &#125;&#125;//组件接口public interface Aggregat &#123; public Iterator createIterator();&#125;//组件实现类public class ConcreteAggregat implements Aggregat &#123; private Vector vector = null; public Iterator createIterator() &#123; return new ConcreteIterator(vector); &#125; public ConcreteAggregat() &#123; vector = new Vector(); vector.add(\"vector1\"); vector.add(\"vector2\"); vector.add(\"vector3\"); &#125; public Vector getVector() &#123; return vector; &#125; public void setVector(Vector vector) &#123; this.vector = vector; &#125;&#125;//客户端public class Client &#123; public static void main(String[] args) &#123; final Aggregat agg = new ConcreteAggregat(); final Iterator iterator = agg.createIterator(); System.out.println(iterator.first()); while (!iterator.isDone()) &#123; System.out.println(iterator.next()); &#125; &#125;&#125;","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"maven常用命令","slug":"maven常用命令","date":"2016-02-05T03:08:28.000Z","updated":"2018-04-04T10:54:24.461Z","comments":true,"path":"2016/02/05/maven常用命令/","link":"","permalink":"http://yoursite.com/2016/02/05/maven常用命令/","excerpt":"","text":"maven 打jar包：1mvn package maven 清除项目:1mvn clean maven 转eclipse项目:1mvn eclipse:eclipse maven 转idea项目1mvn idea:idea maven 拷贝依赖1mvn dependency:copy-dependencies 在maven项目下创建lib文件夹：1mvn dependency:copy-dependencies -DoutputDirectory=lib mvn安装jar包到本地仓库12345mvn install -Dfile=./target/yourjar.jar-DgroupId= -DartifactId=-Dversion=0.0.1-SNAPSHOT -Dpackaging=jar mvn 下载jar包对应的源码1234mvn dependency:sourcesmvn dependency:resolve -Dclassifier=javadoc#第一个命令是尝试下载在pom.xml中依赖的文件的源代码。#第二个命令：是尝试下载对应的javadocs mvn项目所需的pom文件查询地址： http://mvnrepository.com/http://search.maven.org maven 打包时指定主类123456789101112131415161718192021222324252627&lt;build&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;!--这个plugin不要删除，为了屏蔽上层需要检查代码是否JAVA1.6，因为我们用了JAVA1.8--&gt; &lt;plugin&gt; &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt; &lt;artifactId&gt;animal-sniffer-maven-plugin&lt;/artifactId&gt; &lt;version&gt;$&#123;mvn.animal.sniffer.version&#125;&lt;/version&gt; &lt;executions&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;archive&gt; &lt;manifest&gt; &lt;mainClass&gt;主类&lt;/mainClass&gt; &lt;/manifest&gt; &lt;/archive&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 使用maven编译scala https://github.com/nileader/note/wiki/using-maven-build-scalasbt 参考 ： http://www.scala-sbt.org/release/tutorial/zh-cn/index.html","categories":[],"tags":[{"name":"maven","slug":"maven","permalink":"http://yoursite.com/tags/maven/"}]},{"title":"linux中常用的一些命令","slug":"linux中常用的一些命令","date":"2016-01-02T13:26:36.000Z","updated":"2018-04-04T10:33:01.435Z","comments":true,"path":"2016/01/02/linux中常用的一些命令/","link":"","permalink":"http://yoursite.com/2016/01/02/linux中常用的一些命令/","excerpt":"","text":"tshark抓包1sudo tshark -s 512 -i eth0 -n -f &apos;tcp dst port 80&apos; -R &apos;http.host and http.request.uri&apos; -T fields -e http.host -e http.request.uri -l | tr -d &apos;\\t&apos; 查看CPU的型号1cat /proc/cpuinfo | grep name | cut -f2 -d: |uniq -c 查看CPU 几核几线程12grep &apos;processor&apos; /proc/cpuinfo |sort -u |wc -lgrep &apos;core id&apos; /proc/cpuinfo ｜sort -u |wc -l 以人性化的展示文件大小1du -h file 文本按照列进行合并1paste -d\" \" file1 file2 &gt;&gt; newFile 查看端口被哪个进程占用 以80端口为例:1sudo lsof -i: 80 端口扫描：1nmap ip 删除txt文本中的第一列的命令：1sed -i -r -e &quot;s/^[[:space:]]+//&quot; -e &quot;s/^[^[:space:]]+[[:space:]]+//&quot; *.txt 把log.txt中的前600行追加到log1.txt中去1sed -n &apos;1,600 p&apos; log.txt &gt; log1.txt 查看文件的编码：1enca -L zh filename.java 解压/压缩 命令：后缀为gz:12解压：gzip -d FileName.gz压缩：gzip FileName 后缀为.tar.gz12解压：tar zxvf FileName.tar.gz压缩：tar zcvf FileName.tar.gz 压缩为zip1zip -r myfile.zip myfile/* 后缀为.bz212解压：bzip2 -d fleName.bz2压缩： bzip2 -z fileName 后缀为.rar12解压：rar a FileName.rar压缩：r ar e FileName.rar 后缀为.tgz1解压：tar zxvf FileName.tgz linux 查看外网ip12curl ifconfig.mecurl http://members.3322.org/dyndns/getip 在控制台打开某个文件窗口1nautilus /home/*** 输出某一列1cat ××.txt |awk &apos;&#123;print $1&#125;&apos; &gt;&gt; out.txt 循环读取文件夹中的文件并保存为新的文件12345678910for file in *do if test -f $file then #echo $file is file! cat $file |awk &apos;&#123;print $2&#125;&apos; &gt;&apos;N&apos;$file else echo $file is mulu! fidone windows文件拷贝到linux乱码时 指定编码1iconv -f GBK -t UTF-8 file1 -o file2 批量转码shell123456#!/bin/shfor i in *doiconv -f gb2312 -t utf-8 $i &gt;tmpcp tmp $idone 文本去空格1sed s/[[:space:]]//g 文本文件内容洗牌1cat in.txt | awk &apos;BEGIN&#123;srand()&#125;&#123;print rand()&quot;\\t&quot;$0&#125;&apos; | sort -k1,1 -n | cut -f2- &gt; out.txt 去引号12sed &apos;s/&quot;//g&apos;tr -d &apos;&quot;&apos; 123awk -F &apos;,&apos; &apos;&#123;print $14,$15&#125;&apos; cup14w15w &gt;&gt; newcuptr -d \\&quot; &lt; file cut -d\\&quot; -f2 file 12cat tag3 | awk &apos;&#123;if($0 ~ /ag/) print &quot; &quot;; else print &quot;C&quot;$0+1 &#125;&apos; &gt;&gt; tag5~ /ag/ 模糊匹配 shell中一行变一列1cat inputFile |tr &quot;\\n&quot; &quot; &quot; 参考 &gt;http://linuxtools-rst.readthedocs.io/zh_CN/latest/base/index.htmlhttp://man.linuxde.net/tee","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]}]}